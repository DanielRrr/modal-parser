module ModalParser where

import System.IO
import Data.Functor.Identity
import Control.Monad

import Text.Parsec.Prim
import Text.ParserCombinators.Parsec
import Text.ParserCombinators.Parsec.Expr
import Text.Parsec.Token (GenLanguageDef, GenTokenParser)
-- import qualified Text.Parsec.Token
import Text.ParserCombinators.Parsec.Language
import qualified Text.ParserCombinators.Parsec.Token as Token

import AST

-- | Parse error
data Error = NonWFF

-- | the part of the language definition with binary operators
langDef :: GenLanguageDef String a Identity
langDef =
  emptyDef { Token.reservedNames   = ["!", "K"]
           , Token.reservedOpNames = ["&", "v", "->", "~"] }

-- | The lexer generated by langDef
lexer :: GenTokenParser String a Identity
lexer = Token.makeTokenParser langDef

-- | Generates a parser by a given list of tokes
reservedOp :: String -> ParsecT String a Identity ()
reservedOp = Token.reservedOp lexer

-- | Parenthesising
parens :: ParsecT String u Identity a -> ParsecT String u Identity a
parens = Token.parens lexer

-- | Integer parser
integer :: ParsecT String u Identity Integer
integer = Token.integer lexer

-- | Whitespace parsec
whiteSpace = Token.whiteSpace lexer

-- | The list of all Boolean operators
booleanOperators :: [[Operator Char st Form]]
booleanOperators = [ [Prefix (reservedOp "~" >> return Neg)]
                   , [Infix  (reservedOp "->" >> return Impl) AssocRight ]
                   , [ Infix  (reservedOp "v" >> return Disj) AssocLeft,
                       Infix  (reservedOp "&" >> return Conj) AssocLeft]]

-- | Proposition variable parser
parseVar :: Parser Form
parseVar = do
  char 'p'
  i <- integer
  return $ PropVar i

-- | Boolean formula parser
bTerm :: Parser Form
bTerm = parens booleanExpressions <|> parseVar

-- | Boolean expressions parser
booleanExpressions :: Parser Form
booleanExpressions = buildExpressionParser booleanOperators bTerm

-- | Parsing an agent's name
parseAgentName :: Parser String
parseAgentName = many1 $ letter <|> char '\''

-- | Parsing K-modalised formula
parseK :: Parser Form
parseK = do
  char 'K'
  space
  v <- parseAgentName
  space
  form <- parseFormula
  return $ K v form

parseK' :: Parser Form
parseK' = parens parseK <|> parseK

-- | Parsing Dyn-modalised formula
parseDyn :: Parser Form
parseDyn = do
  char '['
  char '!'
  form1 <- parseFormula
  char ']'
  form2 <- parseFormula
  return $ Dyn form1 form2

parseDyn' :: Parser Form
parseDyn' = parens parseDyn <|> parseDyn

-- | Parse a formula
formula' :: Parser Form
formula' = parseK' <|> parseDyn' <|> booleanExpressions 

-- | Parse a (parenthesised) formula
parseFormula :: Parser Form
parseFormula = parens formula' <|> formula'

whileParser :: Parser Form
whileParser = whiteSpace >> parseFormula
